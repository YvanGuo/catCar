C51 COMPILER V9.56.0.0   HW_GPIOCTL51                                                      03/17/2019 22:24:23 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE HW_GPIOCTL51
OBJECT MODULE PLACED IN .\list\hw_gpioCtl51.obj
COMPILER INVOKED BY: E:\keil_c51\C51\BIN\C51.EXE driver\51\hw_gpioCtl51.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXT
                    -END PRINT(.\list\hw_gpioCtl51.lst) TABS(2) OBJECT(.\list\hw_gpioCtl51.obj)

line level    source

   1          
   2          /*------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited -------------------------------*/
   4          /* --- STC 1T Series MCU RC Demo -----------------------------------*/
   5          /* --- Mobile: (86)13922805190 -------------------------------------*/
   6          /* --- Fax: 86-0513-55012956,55012947,55012969 ---------------------*/
   7          /* --- Tel: 86-0513-55012928,55012929,55012966 ---------------------*/
   8          /* --- Web: www.GXWMCU.com -----------------------------------------*/
   9          /* --- QQ:  800003751 ----------------------------------------------*/
  10          /* If you want to use the program or the program referenced in the  */
  11          /* article, please specify in which data and procedures from STC    */
  12          /*------------------------------------------------------------------*/
  13          
  14          /*************  ¹¦ÄÜËµÃ÷  **************
  15          
  16          ±¾ÎÄ¼þÎªSTC8xxxÏµÁÐµÄ¶Ë¿Ú³õÊ¼»¯³ÌÐò,ÓÃ»§¼¸ºõ¿ÉÒÔ²»ÐÞ¸ÄÕâ¸ö³ÌÐò.
  17          
  18          
  19          ******************************************/
  20          
  21          #include "hw_gpioCtl51.h"
  22          
  23          typedef struct GPIO_InitTypeDef
  24          {
  25            uint8 Pin;        //ÒªÉèÖÃµÄ¶Ë¿Ú    Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
  26            uint8 Mode;       //IOÄ£Ê½,  4¸öÑ¡1,  GPIO_PullUp(×¼Ë«Ïò¿Ú),GPIO_HighZ(¸ß×èÊäÈë),GPIO_OUT_OD(¿ªÂ©Ä£Ê½),GPIO_O
             -UT_PP(ÍÆÍìÊä³ö)
  27            uint8 PullUp_3K7;     //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
  28            uint8 SchmittDisable;   //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
  29          } GPIO_InitTypeDef;
  30          
  31          
  32          //========================================================================
  33          // º¯Êý: u8 GPIO_Inilize(u8 GPIO, GPIO_InitTypeDef *GPIOx)
  34          // ÃèÊö: ³õÊ¼»¯IO¿Ú, ½«IOÉèÖÃÎª×¼Ë«Ïò¿Ú¡¢ÍÆÍìÊä³ö¡¢¿ªÂ©Êä³ö¡¢¸ß×èÊäÈëÕâ4ÖÖÄ£Ê½Ö®Ò», ²¢¿ÉÒÔÔÊÐíÄÚ²¿¶îÍâµÄ3.
             -7KÉÏÀ­µç×è.
  35          // ²ÎÊý:  GPIO: Òª³õÊ¼»¯µÄIO, È¡ÖµGPIO_P0 ~ GPIO_P7.
  36          //       GPIOx: ½á¹¹ÌåÖ¸Õë,Çë²Î¿¼GPIO.hÀïµÄ¶¨Òå.
  37          // ·µ»Ø: ³É¹¦·µ»Ø0, ´íÎó·µ»Ø1.
  38          // °æ±¾: V1.0, 2018-3-22
  39          //========================================================================
  40          static uint8  GPIO_Inilize(uint8 GPIO, GPIO_InitTypeDef *GPIOx)
  41          {
  42   1        if((GPIO > GPIO_P7) || (GPIOx->Mode > GPIO_OUT_PP))   return 1; //´íÎó
  43   1      
  44   1        #ifdef STC8XXXX
                EAXSFR(); //·ÃÎÊÀ©Õ¹SFR(XSFR)
                #endif
  47   1        if(GPIO == GPIO_P0)
  48   1        {
  49   2          if(GPIOx->Mode == GPIO_PullUp)    P0M1 &= ~GPIOx->Pin,  P0M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
  50   2          if(GPIOx->Mode == GPIO_HighZ)   P0M1 |=  GPIOx->Pin,  P0M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
  51   2          if(GPIOx->Mode == GPIO_OUT_OD)    P0M1 |=  GPIOx->Pin,  P0M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
  52   2          if(GPIOx->Mode == GPIO_OUT_PP)    P0M1 &= ~GPIOx->Pin,  P0M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
C51 COMPILER V9.56.0.0   HW_GPIOCTL51                                                      03/17/2019 22:24:23 PAGE 2   

  53   2          #ifdef STC8XXXX
                  P0PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P0NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
  57   2        }
  58   1        if(GPIO == GPIO_P1)
  59   1        {
  60   2          if(GPIOx->Mode == GPIO_PullUp)    P1M1 &= ~GPIOx->Pin,  P1M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
  61   2          if(GPIOx->Mode == GPIO_HighZ)   P1M1 |=  GPIOx->Pin,  P1M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
  62   2          if(GPIOx->Mode == GPIO_OUT_OD)    P1M1 |=  GPIOx->Pin,  P1M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
  63   2          if(GPIOx->Mode == GPIO_OUT_PP)    P1M1 &= ~GPIOx->Pin,  P1M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
  64   2          #ifdef STC8XXXX
                  P1PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P1NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
  68   2        }
  69   1        if(GPIO == GPIO_P2)
  70   1        {
  71   2          if(GPIOx->Mode == GPIO_PullUp)    P2M1 &= ~GPIOx->Pin,  P2M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
  72   2          if(GPIOx->Mode == GPIO_HighZ)   P2M1 |=  GPIOx->Pin,  P2M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
  73   2          if(GPIOx->Mode == GPIO_OUT_OD)    P2M1 |=  GPIOx->Pin,  P2M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
  74   2          if(GPIOx->Mode == GPIO_OUT_PP)    P2M1 &= ~GPIOx->Pin,  P2M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
  75   2          #ifdef STC8XXXX
                  P2PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P2NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
  79   2        }
  80   1        if(GPIO == GPIO_P3)
  81   1        {
  82   2          if(GPIOx->Mode == GPIO_PullUp)    P3M1 &= ~GPIOx->Pin,  P3M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
  83   2          if(GPIOx->Mode == GPIO_HighZ)   P3M1 |=  GPIOx->Pin,  P3M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
  84   2          if(GPIOx->Mode == GPIO_OUT_OD)    P3M1 |=  GPIOx->Pin,  P3M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
  85   2          if(GPIOx->Mode == GPIO_OUT_PP)    P3M1 &= ~GPIOx->Pin,  P3M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
  86   2          #ifdef STC8XXXX
                  P3PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P3NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
  90   2        }
  91   1        if(GPIO == GPIO_P4)
  92   1        {
  93   2          if(GPIOx->Mode == GPIO_PullUp)    P4M1 &= ~GPIOx->Pin,  P4M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
  94   2          if(GPIOx->Mode == GPIO_HighZ)   P4M1 |=  GPIOx->Pin,  P4M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
  95   2          if(GPIOx->Mode == GPIO_OUT_OD)    P4M1 |=  GPIOx->Pin,  P4M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
  96   2          if(GPIOx->Mode == GPIO_OUT_PP)    P4M1 &= ~GPIOx->Pin,  P4M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
  97   2          #ifdef STC8XXXX
                  P4PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P4NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
 101   2        }
 102   1        if(GPIO == GPIO_P5)
 103   1        {
 104   2          if(GPIOx->Mode == GPIO_PullUp)    P5M1 &= ~GPIOx->Pin,  P5M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
 105   2          if(GPIOx->Mode == GPIO_HighZ)   P5M1 |=  GPIOx->Pin,  P5M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
 106   2          if(GPIOx->Mode == GPIO_OUT_OD)    P5M1 |=  GPIOx->Pin,  P5M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
 107   2          if(GPIOx->Mode == GPIO_OUT_PP)    P5M1 &= ~GPIOx->Pin,  P5M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
 108   2          #ifdef STC8XXXX
                  P5PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P5NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
 112   2        }
 113   1        if(GPIO == GPIO_P6)
 114   1        {
C51 COMPILER V9.56.0.0   HW_GPIOCTL51                                                      03/17/2019 22:24:23 PAGE 3   

 115   2          if(GPIOx->Mode == GPIO_PullUp)    P6M1 &= ~GPIOx->Pin,  P6M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
 116   2          if(GPIOx->Mode == GPIO_HighZ)   P6M1 |=  GPIOx->Pin,  P6M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
 117   2          if(GPIOx->Mode == GPIO_OUT_OD)    P6M1 |=  GPIOx->Pin,  P6M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
 118   2          if(GPIOx->Mode == GPIO_OUT_PP)    P6M1 &= ~GPIOx->Pin,  P6M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
 119   2          #ifdef STC8XXXX
                  P6PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P6NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
 123   2        } 
 124   1        if(GPIO == GPIO_P7)
 125   1        {
 126   2          if(GPIOx->Mode == GPIO_PullUp)    P7M1 &= ~GPIOx->Pin,  P7M0 &= ~GPIOx->Pin;   //ÉÏÀ­×¼Ë«Ïò¿Ú
 127   2          if(GPIOx->Mode == GPIO_HighZ)   P7M1 |=  GPIOx->Pin,  P7M0 &= ~GPIOx->Pin;   //¸¡¿ÕÊäÈë
 128   2          if(GPIOx->Mode == GPIO_OUT_OD)    P7M1 |=  GPIOx->Pin,  P7M0 |=  GPIOx->Pin;   //¿ªÂ©Êä³ö
 129   2          if(GPIOx->Mode == GPIO_OUT_PP)    P7M1 &= ~GPIOx->Pin,  P7M0 |=  GPIOx->Pin;   //ÍÆÍìÊä³ö
 130   2          #ifdef STC8XXXX
                  P7PU  = GPIOx->PullUp_3K7;    //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  P7NCS = GPIOx->SchmittDisable;  //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 | Pin3
                  #endif
 134   2        }
 135   1        
 136   1        #ifdef STC8XXXX
                EAXRAM(); //·ÃÎÊÀ©Õ¹RAM(XRAM)
                #endif
 139   1        return 0; //³É¹¦
 140   1      }
 141          
 142          void HW_GPIO_config(uint8 pin, PIN_MODE mode)
 143          {
 144   1        GPIO_InitTypeDef  GPIO_InitStructure;       //½á¹¹¶¨Òå
 145   1        GPIO_InitStructure.Pin            = pin%8;  //Ö¸¶¨ÒªÉèÖÃµÄ¶Ë¿Ú    Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pi
             -n0 | Pin3
 146   1        GPIO_InitStructure.PullUp_3K7     = 0;        //ÄÚ²¿ÉÏÀ­3.7Kµç×è, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin
             -0 | Pin3
 147   1        GPIO_InitStructure.SchmittDisable = 0;        //½ûÖ¹Ê©ÃÜÌØÊäÈë, Pin0~Pin7»òPinAll, ¶à¸öÏîÓÃ»ò²Ù×÷, ±ÈÈç Pin0 
             -| Pin3
 148   1        
 149   1        switch(mode){
 150   2          case OUTPUT:{
 151   3          
 152   3            GPIO_InitStructure.Mode = GPIO_OUT_PP;  //Ö¸¶¨IOµÄÄ£Ê½, 4¸öÑ¡1, GPIO_PullUp(×¼Ë«Ïò¿Ú),GPIO_HighZ(¸ß×èÊäÈ
             -ë),GPIO_OUT_OD(¿ªÂ©Ä£Ê½),GPIO_OUT_PP(ÍÆÍìÊä³ö)
 153   3            break;
 154   3          }
 155   2          case INPUT:{
 156   3          
 157   3            GPIO_InitStructure.Mode = GPIO_HighZ;
 158   3            break;
 159   3          }
 160   2          case INPUT_PULLUP:{
 161   3          
 162   3            GPIO_InitStructure.Mode = GPIO_PullUp;
 163   3            GPIO_InitStructure.PullUp_3K7 = pin%8;
 164   3            break;
 165   3          }
 166   2          case PWM:{
 167   3          
 168   3            GPIO_InitStructure.Mode = GPIO_OUT_PP;
 169   3            break;
 170   3          }
 171   2          default:
 172   2            GPIO_InitStructure.Mode = GPIO_OUT_PP;
C51 COMPILER V9.56.0.0   HW_GPIOCTL51                                                      03/17/2019 22:24:23 PAGE 4   

 173   2            break;
 174   2        }
 175   1        
 176   1        
 177   1        GPIO_Inilize(pin/8,&GPIO_InitStructure);  //³õÊ¼»¯
 178   1      
 179   1      }
 180          
 181          void HW_GPIO_digitalWrite(uint8 pin, int32 val)
 182          {
 183   1        uint8 gpioGruop = pin/8;
 184   1        unsigned char gpioGruopPinBit = 1;
 185   1        gpioGruopPinBit = gpioGruopPinBit<<pin%8;
 186   1        switch(gpioGruop){
 187   2        
 188   2          case 0:{
 189   3          
 190   3              if(LOW == val){
 191   4              
 192   4                P0 &= ~gpioGruopPinBit;
 193   4              }else{
 194   4              
 195   4                P0 |= gpioGruopPinBit;
 196   4              }
 197   3              
 198   3              break;
 199   3          }
 200   2          case 1:{
 201   3          
 202   3              if(LOW == val){
 203   4              
 204   4                P1 &= ~gpioGruopPinBit;
 205   4              }else{
 206   4              
 207   4                P1 |= gpioGruopPinBit;
 208   4              }
 209   3              break;
 210   3          }
 211   2          case 2:{
 212   3          
 213   3              if(LOW == val){
 214   4              
 215   4                P2 &= ~gpioGruopPinBit;
 216   4              }else{
 217   4              
 218   4                P2 |= gpioGruopPinBit;
 219   4              }
 220   3              break;
 221   3          }
 222   2          case 3:{
 223   3          
 224   3              if(LOW == val){
 225   4              
 226   4                P3 &= ~gpioGruopPinBit;
 227   4              }else{
 228   4              
 229   4                P3 |= gpioGruopPinBit;
 230   4              }
 231   3              break;
 232   3          }
 233   2          case 4:{
 234   3          
C51 COMPILER V9.56.0.0   HW_GPIOCTL51                                                      03/17/2019 22:24:23 PAGE 5   

 235   3              if(LOW == val){
 236   4              
 237   4                P4 &= ~gpioGruopPinBit;
 238   4              }else{
 239   4              
 240   4                P4 |= gpioGruopPinBit;
 241   4              }
 242   3              break;
 243   3          }
 244   2          case 5:{
 245   3          
 246   3              if(LOW == val){
 247   4              
 248   4                P5 &= ~gpioGruopPinBit;
 249   4              }else{
 250   4              
 251   4                P5 |= gpioGruopPinBit;
 252   4              }
 253   3              break;
 254   3          }
 255   2          case 6:{
 256   3          
 257   3              if(LOW == val){
 258   4              
 259   4                P6 &= ~gpioGruopPinBit;
 260   4              }else{
 261   4              
 262   4                P6 |= gpioGruopPinBit;
 263   4              }
 264   3              break;
 265   3          }
 266   2          case 7:{
 267   3          
 268   3              if(LOW == val){
 269   4              
 270   4                P7 &= ~gpioGruopPinBit;
 271   4              }else{
 272   4              
 273   4                P7 |= gpioGruopPinBit;
 274   4              }
 275   3              break;
 276   3          }
 277   2          
 278   2          default:
 279   2            break;
 280   2        }
 281   1      
 282   1      }
 283          
 284          uint8 HW_GPIO_digitalRead(uint8 pin)
 285          {
 286   1        uint8 retVal = 0;
 287   1        uint8 gpioGruop = pin/8;
 288   1        unsigned char gpioGruopPinBit = 1;
 289   1        gpioGruopPinBit = gpioGruopPinBit<<pin%8;
 290   1        
 291   1        
 292   1        switch(gpioGruop){
 293   2        
 294   2          case 0:{
 295   3              P0 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 296   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
C51 COMPILER V9.56.0.0   HW_GPIOCTL51                                                      03/17/2019 22:24:23 PAGE 6   

 297   3              _nop_();  //
 298   3              retVal = P0;
 299   3              retVal &= gpioGruopPinBit;
 300   3              break;
 301   3          }
 302   2          case 1:{
 303   3              P1 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 304   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
 305   3              _nop_();  //
 306   3              retVal = P1;
 307   3              retVal &= gpioGruopPinBit;
 308   3              break;
 309   3          }
 310   2          case 2:{
 311   3              P2 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 312   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
 313   3              _nop_();  //
 314   3              retVal = P2;
 315   3              retVal &= gpioGruopPinBit;
 316   3              break;
 317   3          }
 318   2          case 3:{
 319   3              P3 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 320   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
 321   3              _nop_();  //
 322   3              retVal = P3;
 323   3              retVal &= gpioGruopPinBit;
 324   3              break;
 325   3          }
 326   2          case 4:{
 327   3              P4 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 328   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
 329   3              _nop_();  //
 330   3              retVal = P4;
 331   3              retVal &= gpioGruopPinBit;
 332   3              break;
 333   3          }
 334   2          case 5:{
 335   3              P6 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 336   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
 337   3              _nop_();  //
 338   3              retVal = P5;
 339   3              retVal &= gpioGruopPinBit;
 340   3              break;
 341   3          }
 342   2          case 6:{
 343   3              P6 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 344   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
 345   3              _nop_();  //
 346   3              retVal = P6;
 347   3              retVal &= gpioGruopPinBit;
 348   3              break;
 349   3          }
 350   2          case 7:{
 351   3              P7 |= gpioGruopPinBit;  // ¶ÁÈ¡Ç°ÏÈÊ¹ÄÜÄÚ²¿ÈõÉÏÀ­µç×è
 352   3              _nop_();  // µÈ´ýÁ½¸öÊ±ÖÓ
 353   3              _nop_();  //
 354   3              retVal = P7;
 355   3              retVal &= gpioGruopPinBit;
 356   3              break;
 357   3          }
 358   2          
C51 COMPILER V9.56.0.0   HW_GPIOCTL51                                                      03/17/2019 22:24:23 PAGE 7   

 359   2          default:
 360   2            break;
 361   2        }
 362   1        
 363   1        return retVal;
 364   1      
 365   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    879    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
